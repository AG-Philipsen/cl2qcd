\subsection{Input-file}
All informations on run-time options are passed to the programme in an input file. The name of that file is the only command line option to be given when calling the executable. This file contains one line per option/variable with the format\\
\verb+OPTIONNAME = +\textit{option}.\\
If one option name occurs several times, the last instance is used. It is possible to have comment lines starting with ``\#''.
The list of options and variables is given in table~\ref{tab:options}.

\begin{sidewaystable}
%\begin{table}
\begin{tabular}{llcc}
\verb+OPTIONNAME+ & description                        & possible values              & default \\
\hline
\verb+kappa+      & hopping parameter $\kappa$         & $0<\kappa<\infty$            & 0.125 \\
\verb+beta+       & lattice coupling $\beta$           & $0<\beta<\infty$             & 4 \\
\verb+mu+         & twisted mass parameter $\mu$       & $0<\mu<\infty$               & 0.006 \\
\verb+cgmax+      & maximum number of CG iterations    & $1<\texttt{cgmax}<\infty$    & 1000 \\
\verb+prec+       & precision of gaugefield (from file)& 32, 64                       & 64 \\
\verb+startcondition+ & start condition                & hot, cold, continue          & cold \\
\verb+thermalizationsteps+ & thermalisation steps      & $0\le\texttt{thermalizationsteps}<\infty$ & 0 \\
\verb+heatbathsteps+  & heatbath steps                 & $0<\texttt{heatbathsteps}<\infty$ & 1000 \\
\verb+writefrequency+  & frequency to write gaugeobs.  & $1<\texttt{writefrequency}<\infty$ & 1 \\
\verb+saveconfigs+  & if to save gauge configs at all  & true, yes; false, no & FALSE \\
\verb+savefrequency+  & frequency to save gauge files  & $0<\texttt{savefrequency}<\infty$ & 100 \\
\verb+sourcefile+  & name of gauge config file         & string                       &  not defined
\end{tabular}
\caption{List of all possible options and variables that can be passed to the programme in the input file.} \label{tab:options}
%\end{table}
\end{sidewaystable}

\subsection{Configurations}
Configuation files can be read from ILDG format. \file{host\_readgauge.h} and \file{host\_readgauge.cpp} provide a class \ctype{sourcefileparameters} which reads in all information from a given tmlqcd file concerning gauge-configurations. Not fully implemented is the read-in of fermion-propagators. 

The reading-routine is based on a stand-alone-program that was written in C. The metainformations about the data are saved in XML- and XLF-format (see also appendix), while the actual data is saved binary. To read XLF and XLM files the LIME- (source) and XLM-libraries are used, which are only available for C. The routines are not optimized regarding speed or memory-usage since the reading of the data should only take place at the beginning of the programrun.

The reading of the metainforamtions was specifically tested for two tmlqcd-files created with different version of the hmc (5.1.1 and 5.1.5). Everything is read and saved into particular variables. If there are fermion-informations in the sourcefile, they are saved successively for each fermion. Here, only informations about the first are stored, all others are skipped. This has not been implemented because there is most likely no need to read in propagators. There were some problems in reading metainforamtions from files other than from the tmlqcd-files, revealing the no-optimized nature of the routine. So there might be the need to work in the specific layout of the file one wishes to read in.

The binary data is saved into a field which is a parameter of the routine (as a pointer). The precision in which the data was saved is extracted before during the metainformation gain. ILDG is always stored big endian, so the routine checks the local endianness with htons() to get the right order of the bytes.

In \file{host\_writegaugefield.h} and \file{host\_writegaugefield.cpp} functions to save Gaugefield-Configurations are contained. They are saved in the form \file{conf.XXXXX} with a five-digit number labeling the specific configuration. If a file of other name is read in, the program starts with \file{conf.00000}. Not implemented so far is the ildg-checksum. Here, only a stubb is written into the limefile!!


\subsection{Compiler options}
\subsubsection{\define{RECONSTRUCT\_TWELVE}}
If \define{RECONSTRUCT\_TWELVE} is defined, SU(3) matrices are stored using 12 floating point numbers of type \ctype{hmc\_float}. They represent the first two rows of the matrix. The last row is reconstructed~\cite{Clark:2009wm}. The 12 numbers are stored using a single index $n=i+(N_c-1)j$ for the components $U_{ij}$. The reconstruction is done in \file{operations.cpp}. You have 
\[ j = \text{int} \left(\frac{n}{N_c-1}\right) \]
and
\[ i = n - (N_c-1)j\;. \]
Thus the numbering works as follows:
\[ \left(\begin{array}{rrr} u_{00} & u_{01} & u_{02} \\ u_{10} & u_{11} & u_{12} \\ u_{20} & u_{21} & u_{22}\end{array}\right)
=
\left(\begin{array}{rrr} u_{0} & u_{2} & u_{4} \\ u_{1} & u_{3} & u_{5} \\ c_0 & c_1 & c_2 \end{array}\right)
\]
The reconstruction of the elements $c_\text{ncomp}$ of the matrix \ctype{in} is done with the function \function{reconstruct\_su3(hmc\_su3matrix* in, int ncomp)}.

\subsubsection{\define{SOURCEDIR}}
\define{SOURCEDIR} is passed to the OpenCL \ctype{clprogram} in order to find the OpenCL kernel files.
\subsubsection{\define{\_OPENMP}}
\define{\_OPENMP} can be used to activate OpenMP.
\subsubsection{\define{\_USEDOUBLEPREC\_}}
\define{\_USEDOUBLEPREC\_} switches to double precision floating point numbers on the OpenCL device.
\subsubsection{internal switches}
\begin{itemize}
\item 
\define{\_INKERNEL\_} allows to check whether OpenCL kernel code or C++ host code is meant to be compiled (some \file{globalheaders.h} and \file{types.h} are included by both of them).
\end{itemize}

\subsection{Output}

Despite the possibiliy to write a gauge-configuration to a file (see above), a time-measurement is saved by default into the file \file{time\_measurement\_0/1}, where 1 and 0 is used in the case of \file{RECONSTRUCT\_TWELVE} or not, respectivley. Furthermore, in \file{host\_gaugeobservables} there is a function to print out gaugeobservables into a file. This is done in the following order:

\begin{verbatim}
	Iteration number
	Plaquette
	Plaquette in time-direction
	Plaquette in space-direction
	Real(Polyakovloop)
	Im(Polyakovloop)
	Abs(Polyakovloop).
\end{verbatim}
Here, the observables are saved with a precision of 15.


