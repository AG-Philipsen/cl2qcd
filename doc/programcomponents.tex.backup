\subsection{\file{globaldefs.h}}
Definitions in \file{globaldefs.h} should be available programme-wide.
\begin{itemize}
\item \define{NC}=3
\item \define{NSPIN}=4
\item \define{NDIM}=4
\item \define{NSPACE}, \define{NTIME}: The spatial and temporal extent is defined at compile time in order to have fixed for-loop lengths. These two definitions are passed to the OpenCL kernels with their compile-time values.
\item \define{VOLSPACE} = \define{NPACE*NSPACE*NSPACE}
\item \define{VOL4D} = \define{VOLSPACE*NTIME}
\item \define{PI} = 3.14159265358979
\item \define{su2\_entries} = 4
\item \define{START\_FROM\_SOURCE}=2, \define{COLD\_START}=0, \define{HOT\_START}=1
\end{itemize}

\subsection{\file{hmcerrs.h}}
\file{hmcerrs.h} defines the error codes as \verb+typedef int hmc_error+:
\begin{itemize}
\item \define{HMC\_SUCCESS}
\item \define{HMC\_STDERR}
\item \define{HMC\_FILEERROR}
\item \define{HMC\_OCLERROR}
\item \define{HMC\_XMLERROR}
\item \define{HMC\_UNDEFINEDERROR}
\end{itemize}

\subsection{\file{types.h}}
\file{types.h} contains typdefs. There are differences between host and kernel code. For both, the basic floating point type is \ctype{hmc\_float}
\begin{verbatim}
#ifdef _USEDOUBLEPREC_
typedef double hmc_float;
#else
typedef float hmc_float;
#endif
\end{verbatim}
With this type \ctype{hmc\_one\_f}=1 is a global constant. For both host and kernel, there is a complex type \ctype{hmc\_complex} with members \ctype{re} and \ctype{im} for real and imaginary part that is based on \ctype{hmc\_float}. \ctype{hmc\_complex\_one}, \ctype{hmc\_complex\_zero}, \ctype{hmc\_complex\_i} are available. All according complex operations are defined in \file{host\_operations.h}.
\subsubsection{Spinor types}
Spinor types have only been defined in the C++ part so far:
\begin{verbatim}
typedef hmc_complex hmc_full_spinor [NSPIN*NC];
typedef hmc_complex hmc_full_spinor_field [NSPIN*NC][VOLSPACE][NTIME];
\end{verbatim}
All according operations are defined in \file{host\_operations.h}.
\subsubsection{Gaugefield and matrix types}
There is \ctype{hmc\_su3matrix} which is used as fundamental data type for SU(3) matrices. Depending on the switch \define{\_RECONSRUCT\_TWELVE\_} it is an array of length \verb+NC*(NC-1)+ or a field with \verb+[NC][NC]+ components.
\ctype{hmc\_staplematrix} is an array of length \verb+NC*NC+ (for reconstruct twelve) or simply a new name for \ctype{hmc\_su3matrix} if all 18 components are stored anyways. The gaugefield ist stored as
\begin{verbatim}
#ifdef _RECONSTRUCT_TWELVE_
typedef hmc_complex hmc_gaugefield [NC*(NC-1)][NDIM][VOLSPACE][NTIME];
#else
typedef hmc_complex hmc_gaugefield [NC][NC][NDIM][VOLSPACE][NTIME];
#endif
\end{verbatim}
All according operations are defined in \file{host\_operations.h}.

On device, the typedefs are as follows:
\begin{verbatim}
typedef hmc_complex hmc_ocl_su3matrix;
typedef hmc_complex hmc_ocl_staplematrix;
typedef hmc_float hmc_ocl_gaugefield;
\end{verbatim}
Thus, the necessary array length has to be allocated each time. Operations are given in \file{opencl\_operations.cl}.

\subsubsection{Random number types}

For the random numbers on the device there is the type clu\_taus\_state, which is just a cl\_uint4. Additionally there is a type rndarray, which is an array of clu\_taus\_states with VOL4D/2 entries. It is meant to store one random number for each thread.


\subsection{Operations}
Local and global operations on the types defined in \file{types.h} are contained in \file{host\_-/opencl\_operations.h} and \file{host\_-/opencl\_operations.cpp} for the host and device, respectivly. There are operations on complex types (conjugation, multiplication,\ldots), matrix types (adjoin, trace, determinant,\ldots), spinor types, and gaugefield types. 

Besides arithmetic operations there are gaugefield functions to initialise cold and hot start as well as start from source. Furthermore interfaces to get and put SU(3) matrix elements of a gaugefield are provided and functions that copy a gaugefield from hmc type to ocl type.

\subsection{Gaugeobservables}
\file{host\_gaugeobservables.h} and \file{host\_gaugeobservables.cpp} provide
\begin{verbatim}
void print_gaugeobservables(hmc_gaugefield* field, usetimer* timer,
                          usetimer * timer2);
void print_gaugeobservables(hmc_gaugefield* field, usetimer* timer, 
                          usetimer * timer2, int iter);
void print_gaugeobservables(hmc_gaugefield* field, usetimer* timer, 
                          usetimer * timer2, int iter, std::string file);
void print_gaugeobservables(hmc_float plaq, hmc_float tplaq, 
                          hmc_float splaq, hmc_complex pol, int iter);
void print_gaugeobservables(hmc_float plaq, hmc_float tplaq, 
                          hmc_float splaq, hmc_complex pol, int iter, 
                          std::string file);

hmc_float plaquette(hmc_gaugefield * field, hmc_float* tplaq, 
                          hmc_float* splaq);
hmc_float plaquette(hmc_gaugefield * field);
hmc_complex polyakov(hmc_gaugefield * field);
hmc_complex spatial_polyakov(hmc_gaugefield * field, int dir);

\end{verbatim}
The print functions print plaquette, temporal and spatial plaquette, real part, imaginary part and absolute value of Polyakov loop to standard out or a file in two versions: One can either give already calculated results or do this within the printing funcktion. Time-Measurement can be done. In the future there should be additional overload-function to also be able to do everything without time-measurement.

\file{host\_gaugefieldoperations.h} and \file{host\_gaugefieldoperations.cpp} provide
\begin{verbatim}
void print_info_source(sourcefileparameters* params);

hmc_error init_gaugefield(hmc_gaugefield* gaugefield,
                          inputparameters* parameters, usetimer* timer);
\end{verbatim}
The print function prints xml-info from an input source file to standard out. \function{init\_gaugefield} initialises a (previously allocated) gaugefield according to the start condition. Note the use of timer which needs to be improved.


\subsection{Usetimer}
\file{host\_usetimer.h} defines an ugly wrapper around a timer class defined in \file{host\_timer.h}. We need to improve this\ldots

\subsection{Geometry}
\file{host\_geometry.h} and \file{host\_geometry.cpp} provide a mapping from from $(x,y,z)$ to one int nspace. The naming scheme is as follows:\\
direction 1 = x; direction 2 = y; direction 3 = z; direction 0 = t. This differs from the ILDG-format!\\
Important: $(x,y,z)$ are always used together and it should be possible to use a different number of space dimensions (defined in \file{globals.h}). $t$ is always apart.
\begin{verbatim}
//switch between (x,y,z) <-> nspace=0,...,VOLSPACE-1
int get_nspace(int* coord);
int get_spacecoord(int nspace, int dir);

int get_neighbor(int nspace, int dir);
int get_lower_neighbor(int nspace, int dir);
\end{verbatim}

\subsection{Update}
In \file{host\_update\_heatbath.h} and \file{host\_update\_heatbath.cpp} the heatbath and overrelaxing algorithms for the gaugefield are given in standard and checkerboard version, where the latter can be used with OpenMP (and perhaps needs one final test). Additionally there is the routine to calculate the staple of a given link.

\begin{verbatim}
void calc_staple(hmc_gaugefield * field, hmc_staplematrix * dest, 
                 const int pos, const int t, const int mu_in);
void heatbath_update (hmc_gaugefield * gaugefield, 
                 const hmc_float beta);
void heatbath_overrelax (hmc_gaugefield * gaugefield, 
                 const hmc_float beta);
void heatbath_update_checkerboard (hmc_gaugefield * gaugefield, 
                 const hmc_float beta);
void heatbath_overrelax_checkerboard (hmc_gaugefield * gaugefield, 
                 const hmc_float beta);
\end{verbatim}

\subsection{Random}

The files \file{host\_random.h} and \file{host\_random.cpp} provide a random number generator for the host taken from Numerical Recipes (cite) called Random which can be initialised with a seed that is currently set to be 50000. For the heatbath one needs a random order of 1,2 and 3 as well as random SU(2)-matrices, which is implemented here according to Kennedy \& Pendleton \cite{Kennedy:1985}. Also, there is the init-function for a random-array that is used as the seed-array for the random-numbers on the device.

\begin{verbatim}
void random_1_2_3 (int rand[3]);
void init_random_seeds(Random random, clu_taus_state * hmc_rndarray, 
                 const int NUM, usetimer * inittime);
void SU2Update(hmc_float dst [su2_entries], const hmc_float alpha);
\end{verbatim}


\subsection{Opencl}
\file{opencl.h} and \file{opencl.cpp} provide a class \function{opencl} which can be used to initialise an OpenCL device and call the heatbath kernel. The kernels needed for the OpenCL-Implementaton are give in \file{opencl\_xxx.cl} files (e.\,g.\ \file{opencl\_operations.cl}). There is a testing kernel which can be called with the according test member function of the OpenCL class. Also, equivalent functions to basically every function defined on the host (except input- and output-operations) can be found in these files.

The kernel files that should be read in to build the OpenCL \function{clprogram} are listed in the \ctype{string} vector \function{cl\_kernels\_file}. When the programme is built, the complete source code is also written to the file \file{cl\_kernelsource.cl} which is meant to allow for debugging.

\subsection{Testing}
\file{host\_testing.h} and \file{host\_testing.cpp} provide a playground for testing. Just have a look\ldots
