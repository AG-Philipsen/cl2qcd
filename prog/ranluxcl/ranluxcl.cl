#ifndef RANLUXCL_CL
#define RANLUXCL_CL

/**** RANLUXCL v1.3.1 **************************************************************

Implements the RANLUX generator of Matrin Luscher, based on the Fortran 77
implementation by Fred James. This OpenCL code is a complete implementation which 
should perfectly replicate the numbers generated by the original Fortran 77
implementation.

***** QUICK USAGE DESCRIPTION ******************************************************

1. Create an OpenCL buffer with room for (<numWorkitems> * 7) float4 variables. I.e.
in C/C++: size_t buffSize = numWorkitems * 7 * sizeof(cl_float4).

2. Pass the buffer and an integer seed <ins> (<ins> larger or equal to zero) to a
kernel that launches ranluxcl_initialization. Stick to relatively small <ins>. For
more on restrictions on <ins> see the section on the initialization function
below. An examle initialization kernel would be:
    #include "ranluxcl.cl"
    __kernel void Kernel_Ranluxcl_Init(private int ins, global float4 *ranluxcltab){
    	ranluxcl_initialization(ins, ranluxcltab);
    }

3. Now the generator is ready for use. Remember to download the seeds first, and
upload them again when done. Example kernel that generates a float4 where each
component is uniformly distributed between 0 and 1, end points not included:
    #include "ranluxcl.cl"
	__kernel void Kernel_Example(__global float4 *ranluxcltab){
		//ranluxclstate is a struct of 7 float4 variables
		//storing the state of the generator.
		ranluxcl_state_t ranluxclstate;

		//Download state into ranluxclstate struct.
		ranluxcl_download_seed(&ranluxclstate, ranluxcltab);

		//Generate a float4 with each component on (0,1),
		//end points not included. We can call ranluxcl as many
		//times as we like until we upload the state again.
		float4 randomnr = ranluxcl(&ranluxclstate);

		//Upload state again so that we don't get the same
		//numbers over again the next time we use ranluxcl.
		ranluxcl_upload_seed(&ranluxclstate, ranluxcltab);
	}

***** MACROS ***********************************************************************

The following macros can optionally be defined:

RANLUXCL_LUX:
Sets the luxury level of the generator. Should be 0-4, or if it is 24 or larger it
sets the p-value of the generator (generally not needed). If this macro is not set
then lux=4 is the default (highest quality). For many applications the high quality
of lux=4 may not be needed. Indeed if two values (each value having 24 random bits) 
are glued together to form a 48-bit value the generator passes all tests in the TestU01
suite already with lux=2. See "TestU01: A C Library for Empirical Testing of Random 
Number Generators" by PIERRE L’ECUYER and RICHARD SIMARD. SWB(224, 10, 24)[24, l] is 
RANLUX with two values glued together to create 48-bit numbers, and we see that it
passes all tests already at luxury value 2.

RANLUXCL_MAXWORKITEMS:
If several OpenCL NDRanges will be running in parallel and the parallel sequences
should be different then this macro should have a value equal or larger than the
largest number of work-items in any of the parallel runs. The default is to use the
current global size, so if all NDRanges are of the same size this need not be
defined. Each parallel instance must also have different seeds <ins>. For example if
we are launching 5120 work-items on GPU1 and 10240 work-items on GPU2 we would use
different seeds for the two generators, and RANLUXCL_MAXWORKITEMS must be defined to
be at least 10240. If GPU1 and GPU2 had the same number of work-items this would not
be necessary.

RANLUXCL_NO_WARMUP:
Turns off the warmup functionality in ranluxcl_initialization. This macro should
generally not be used, since the generators will initially be correlated if it is
defined. The only advantage is that the numbers generated will exactly correspond
to those of the original Fortran 77 implementation.

***** FUNCTIONS: INITIALIZATION ****************************************************

The initialization function is defined as:
void ranluxcl_initialization(int ins, __global float4 *ranluxcltab)

Run once at the very beginning. ranluxcltab should be a buffer with space for 7
float4 variables per work-item in the NDRange. <ins> is the seed to the generator.
For a given <ins> each work-item in the NDRange will generate a different sequence.
If more than one NDRange is used in parallel then <ins> must be different for each
NDRange to avoid identical sequences.

See also the RANLUXCL_MAXWORKITEMS macro above for parallel sequences. As long as either
the RANLUXCL_MAXWORKITEMS macro is set correctly, or all NDRanges are launched with
the same number of work-items, it is sufficient to increment <ins> by one to ensure all
work-items will generate different sequences. 

An underestimate of the highest permissible seed <ins> is given by the smallest of:
(<maxins> = 10^9 / <numWorkitems>) or (<maxins> = 10^9 / RANLUXCL_MAXWORKITEMS).
Please make sure that <ins> is never higher than this since it could cause undetected
problems. For example with 10240 work-items the highest permissible <ins> is about
100 000.

***** FUNCTIONS: SEED UPLOAD/DOWNLOAD **********************************************

The following two functions should be launced at the beginning and end of a kernel
that uses ranluxcl to generate numbers, respectively:

void ranluxcl_download_seed(ranluxcl_state_t *ranluxclstate, __global float4 *ranluxcltab)
Run at the beginning of a kernel to download ranluxcl state data

void ranluxcl_upload_seed(ranluxcl_state_t *ranluxclstate, __global float4 *ranluxcltab)
Run at the end of a kernel to upload state data

***** FUNCTIONS: GENERATION AND SYNCHRONIZATION ************************************

float4 ranluxcl(ranluxcl_state_t *ranluxclstate)
Run to generate a pseudo-random float4 where each component a number between 0 and 1,
end points not included (meaning the number will never be exactly 0 or 1).

void ranluxcl_synchronize(ranluxcl_state_t *ranluxclstate)
Run to synchronize execution in case different work-items have made a different
number of calls to ranluxcl. On SIMD machines this could lead to inefficient execution.
ranluxcl_synchronize allows us to make sure all generators are SIMD-friendly again. Not
needed if all work-items always call ranluxcl the same number of times.

***** PERFORMANCE ******************************************************************

For luxury setting 3, performance on AMD cypress should be ~7*10^9 pseudorandom 
values per second, when not downloading values to host memory (i.e. the values are 
just generated, but not used for anything in particular).

***** DESCRIPTION OF THE IMPLEMENTATION ********************************************

This code closely follows the original Fortran 77 code (see credit section). Here
the differences (and similarities) between RANLUXCL (this implementation) and the
original RANLUX are discussed.

The Fortran 77 implementation uses a simple LCG to initialize the generator, and
so the same approach is taken here. If RANLUXCL is initialized with <ins> = 0 as
seed, the first work-item behaves like the original RANLUX with seed equal 1, the
second work-item as if with seed equal 2 and so on. If <ins> = 1 then the first
work-item behaves like the original RANLUX with seed equal to <numWorkitems> + 1,
and so on for higher <ins> so that we never have overlapping sequences. This is
why the RANLUXCL_MAXWORKITEMS macro must be set if we have different NDRanges with
a different number of work-items.

RANLUX is based on chaos theory, and what we are actually doing when selecting
a luxury value is setting how many values to skip over (causing decorrelation).
The number of values to skip is controlled by the so-called p-value of the
generator. After generating 24 values we skip p - 24 values until again generating
24 values.

This implementation is somewhat modified from the original fortran implementation 
by F. James. Because of the way the OpenCL code is optimized with 4-component 
32-bit float vectors, it is most convenient to always throw away some multiple 
of 24 values (i.e. p is always a multiple of 24).

However, there might be some resonances if we always throw away a multiple of
the seeds table size. Therefore the implementation is slightly more intricate
where p can be a multiple of 4 instead, at a cost to performance (only about 10%
lower than the cleaner 24 values approach on AMD Cypress). These two approaches
are termed planar and planar shift respectively. The idea for the planar approach
comes from the following paper:
Vadim Demchik, Pseudo-random number generators for Monte Carlo simulations on 
Graphics Processing Units, arXiv:1003.1898v1 [hep-lat]

Below the p-values for the original reference implementation are listed along with 
those of the planar shift implementation. Suggested values for the planar approach 
are also presented. When this function is called with RANLUXCL_LUX set to 0-4, the
planar shift values are used. To use the pure planar approach (for some extra
performance with likely undetectable quality decrease), set lux equal to the specific 
p-value.
        
Luxury setting (RANLUXCL_LUX):                   0   1   2   3   4
Original fortran77 implementation by F. James:  24  48  97  223 389
Planar (suggested):                             24  48  120 240 408
Planar shift:                                   24  48  100 224 404

Note that levels 0 and 1 are the same as in the original implementation for both
planar and planar shift. Level 4 of planar shift where p=404 is the same as chosen 
for luxury level 1 by Martin Luescher for his v3 version of RANLUX. Therefore if 
it is considered important to only use "official" values, luxury settings 0, 1 or 
4 of planar shift should be used. It is however unlikely that the other values are 
bad, they just haven't been as extensively used and tested by others.

Variable names are generally the same as in the fortran77 implementation, however 
because of the way the generator is implemented, the i24 and j24 variables are 
no longer needed.

***** CREDIT ***********************************************************************

I have been told by Fred James (the coder) that the original Fortran 77 
implementation (which is the subject of the second paper below) is free to use and 
share. Therefore I am using the MIT license (below). But most importantly please 
always remember to give credit to the two articles by Martin Luscher and Fred James, 
describing the generator and the fortran 77 implementation on which this 
implementation is based, respectively:

Martin Lüscher, A portable high-quality random number generator for lattice 
field theory simulations, Computer Physics Communications 79 (1994) 100-110

F. James, RANLUX: A Fortran implementation of the high-quality pseudorandom 
number generator of Lüscher, Computer Physics Communications 79 (1994) 111-114

***** LICENSE **********************************************************************

Copyright (c) 2011 Ivar Ursin Nikolaisen

Permission is hereby granted, free of charge, to any person obtaining a copy of this 
software and associated documentation files (the "Software"), to deal in the Software 
without restriction, including without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to the following 
conditions:

The above copyright notice and this permission notice shall be included in all copies 
or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

***************************************************************************************/

typedef struct{
	float4 s01to04;
	float4 s05to08;
	float4 s09to12;
	float4 s13to16;
	float4 s17to20;
	float4 s21to24;
	float4 carryin24stepnr; //Fourth component unused
} ranluxcl_state_t;

#define RANLUXCL_TWOM24 0.000000059604644775f
#define RANLUXCL_TWOM12 0.000244140625f

#ifdef RANLUXCL_LUX
#if RANLUXCL_LUX < 0
#error ranluxcl: lux must be zero or positive.
#endif
#else
#define RANLUXCL_LUX 4 //Default to high quality
#endif //RANLUXCL_LUX

//Here the luxury values are defined
#if RANLUXCL_LUX == 0
#define RANLUXCL_NSKIP 0
#elif RANLUXCL_LUX == 1
#define RANLUXCL_NSKIP 24
#elif RANLUXCL_LUX == 2
#define RANLUXCL_NSKIP 76
#elif RANLUXCL_LUX == 3
#define RANLUXCL_NSKIP 200
#elif RANLUXCL_LUX == 4
#define RANLUXCL_NSKIP 380
#else
#define RANLUXCL_NSKIP (RANLUXCL_LUX - 24)
#endif //RANLUXCL_LUX == 0

//Check that nskip is a permissible value
#if RANLUXCL_NSKIP % 4 != 0 
#error nskip must be divisible by 4!
#endif
#if RANLUXCL_NSKIP < 24 && RANLUXCL_NSKIP != 0
#error nskip must be either 0 or >= 24!
#endif
#if RANLUXCL_NSKIP < 0
#error nskip is negative!
#endif

//Check if planar scheme is recovered
#if RANLUXCL_NSKIP % 24 == 0
#define RANLUXCL_PLANAR
#endif

//Check if we will skip at all
#if RANLUXCL_NSKIP == 0
#define RANLUXCL_NOSKIP
#endif

//Single-value global size and id
#define RANLUXCL_NUMWORKITEMS (get_global_size(0) * get_global_size(1) * get_global_size(2))
#define RANLUXCL_MYID (get_global_id(0) + get_global_id(1) * get_global_size(0) + get_global_id(2) * get_global_size(0) * get_global_size(1))

void ranluxcl_download_seed(ranluxcl_state_t *ranluxclstate, __global float4 *ranluxcltab)
{
	(*ranluxclstate).s01to04         = ranluxcltab[RANLUXCL_MYID + 0 * RANLUXCL_NUMWORKITEMS];
	(*ranluxclstate).s05to08         = ranluxcltab[RANLUXCL_MYID + 1 * RANLUXCL_NUMWORKITEMS];
	(*ranluxclstate).s09to12         = ranluxcltab[RANLUXCL_MYID + 2 * RANLUXCL_NUMWORKITEMS];
	(*ranluxclstate).s13to16         = ranluxcltab[RANLUXCL_MYID + 3 * RANLUXCL_NUMWORKITEMS];
	(*ranluxclstate).s17to20         = ranluxcltab[RANLUXCL_MYID + 4 * RANLUXCL_NUMWORKITEMS];
	(*ranluxclstate).s21to24         = ranluxcltab[RANLUXCL_MYID + 5 * RANLUXCL_NUMWORKITEMS];
	(*ranluxclstate).carryin24stepnr = ranluxcltab[RANLUXCL_MYID + 6 * RANLUXCL_NUMWORKITEMS];
}

void ranluxcl_upload_seed(ranluxcl_state_t *ranluxclstate, __global float4 *ranluxcltab)
{
	ranluxcltab[RANLUXCL_MYID + 0 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s01to04;
	ranluxcltab[RANLUXCL_MYID + 1 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s05to08;
	ranluxcltab[RANLUXCL_MYID + 2 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s09to12;
	ranluxcltab[RANLUXCL_MYID + 3 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s13to16;
	ranluxcltab[RANLUXCL_MYID + 4 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s17to20;
	ranluxcltab[RANLUXCL_MYID + 5 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).s21to24;
	ranluxcltab[RANLUXCL_MYID + 6 * RANLUXCL_NUMWORKITEMS] = (*ranluxclstate).carryin24stepnr;
}

float ranluxcl_onestep_1(float4* vec1, float4* vec2, float4* carryin24stepnr){
	float uni, out;
	uni = (*vec1).y - (*vec2).w - (*carryin24stepnr).x;
	if(uni < 0.0f){
		uni += 1.0f;
		(*carryin24stepnr).x = RANLUXCL_TWOM24;
	} else (*carryin24stepnr).x = 0.0f;
	out = ((*vec2).w = uni);

	if(uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).y;

	if(out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
	return out;
}

float ranluxcl_onestep_2(float4* vec1, float4* vec2, float4* carryin24stepnr){
	float uni, out;
	uni = (*vec1).x - (*vec2).z - (*carryin24stepnr).x;
	if(uni < 0.0f){
		uni += 1.0f;
		(*carryin24stepnr).x = RANLUXCL_TWOM24;
	} else (*carryin24stepnr).x = 0.0f;
	out = ((*vec2).z = uni);

	if(uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).x;

	if(out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
	return out;
}

float ranluxcl_onestep_3(float4* vec1, float4* vec2, float4* carryin24stepnr){
	float uni, out;
	uni = (*vec1).w - (*vec2).y - (*carryin24stepnr).x;
	if(uni < 0.0f){
		uni += 1.0f;
		(*carryin24stepnr).x = RANLUXCL_TWOM24;
	} else (*carryin24stepnr).x = 0.0f;
	out = ((*vec2).y = uni);

	if(uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).w;

	if(out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
	return out;
}

float ranluxcl_onestep_4(float4* vec1, float4* vec2, float4* carryin24stepnr){
	float uni, out;
	uni = (*vec1).z - (*vec2).x - (*carryin24stepnr).x;
	if(uni < 0.0f){
		uni += 1.0f;
		(*carryin24stepnr).x = RANLUXCL_TWOM24;
	} else (*carryin24stepnr).x = 0.0f;
	out = ((*vec2).x = uni);

	if(uni < RANLUXCL_TWOM12) out += RANLUXCL_TWOM24 * (*vec1).z;

	if(out == 0.0f) out = RANLUXCL_TWOM24 * RANLUXCL_TWOM24;
	return out;
}

float4 ranluxcl(ranluxcl_state_t *ranluxclstate)
{
	//ranluxcl returns a 4-component float vector where each component is uniformly distributed
	//between 0-1, end points not included.

	float4 out;

	if((*ranluxclstate).carryin24stepnr.z == 0.0f){
		out.x = ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
		out.y = ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
		out.z = ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
		out.w = ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
		(*ranluxclstate).carryin24stepnr.z += 4.0f;
	}

	else if((*ranluxclstate).carryin24stepnr.z == 4.0f){
		out.x = ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
		out.y = ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
		out.z = ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
		out.w = ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
		(*ranluxclstate).carryin24stepnr.z += 4.0f;
	}

	else if((*ranluxclstate).carryin24stepnr.z == 8.0f){
		out.x = ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
		out.y = ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
		out.z = ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
		out.w = ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
		(*ranluxclstate).carryin24stepnr.z += 4.0f;
	}

	else if((*ranluxclstate).carryin24stepnr.z == 12.0f){
		out.x = ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
		out.y = ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
		out.z = ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
		out.w = ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
		(*ranluxclstate).carryin24stepnr.z += 4.0f;
	}

	else if((*ranluxclstate).carryin24stepnr.z == 16.0f){
		out.x = ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
		out.y = ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
		out.z = ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
		out.w = ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
		(*ranluxclstate).carryin24stepnr.z += 4.0f;
	}

	else if((*ranluxclstate).carryin24stepnr.z == 20.0f){
		out.x = ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
		out.y = ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
		out.z = ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
		out.w = ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
		(*ranluxclstate).carryin24stepnr.z = 0.0f;

//The below preprocessor directives are here to recover the simpler planar scheme when nskip is a multiple of 24.
//For the most general planar shift approach, just ignore all #if's below.
#ifndef RANLUXCL_PLANAR
	}

	(*&((*ranluxclstate).carryin24stepnr)).y += 4.0f;
	if((*&((*ranluxclstate).carryin24stepnr)).y == 24.0f){
		(*&((*ranluxclstate).carryin24stepnr)).y = 0.0f;
#endif //RANLUXCL_PLANAR

		int initialskips = (int)((*ranluxclstate).carryin24stepnr.z) ? (24 - (int)((*ranluxclstate).carryin24stepnr.z)) : 0;
		int bulkskips = ((RANLUXCL_NSKIP - initialskips)/24) * 24;
		int remainingskips = RANLUXCL_NSKIP - initialskips - bulkskips;

//We know there won't be any initial skips in the planar scheme
#ifndef RANLUXCL_PLANAR
		//Do initial skips (lack of breaks in switch is intentional).
		switch(initialskips){
			case(20):
				ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
			case(16):
				ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
			case(12):
				ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
			case(8):
				ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
			case(4):
				ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
		}
#endif //RANLUXCL_PLANAR

//Also check if we will ever need to skip at all
#ifndef RANLUXCL_NOSKIP
		for(int i=0; i<bulkskips/24; i++){
			ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_1(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s13to16), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s09to12), &((*ranluxclstate).s01to04), &((*ranluxclstate).carryin24stepnr));
		}
#endif //RANLUXCL_NOSKIP

//There also won't be any remaining skips in the planar scheme
#ifndef RANLUXCL_PLANAR
		//Do remaining skips
		if(remainingskips){
			ranluxcl_onestep_1(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_2(&((*ranluxclstate).s09to12), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_3(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			ranluxcl_onestep_4(&((*ranluxclstate).s05to08), &((*ranluxclstate).s21to24), &((*ranluxclstate).carryin24stepnr));
			
			if(remainingskips > 4){
				ranluxcl_onestep_1(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s05to08), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s01to04), &((*ranluxclstate).s17to20), &((*ranluxclstate).carryin24stepnr));
			}

			if(remainingskips > 8){
				ranluxcl_onestep_1(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s01to04), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s21to24), &((*ranluxclstate).s13to16), &((*ranluxclstate).carryin24stepnr));
			}

			if(remainingskips > 12){
				ranluxcl_onestep_1(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s21to24), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s17to20), &((*ranluxclstate).s09to12), &((*ranluxclstate).carryin24stepnr));
			}

			if(remainingskips > 16){
				ranluxcl_onestep_1(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_2(&((*ranluxclstate).s17to20), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_3(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
				ranluxcl_onestep_4(&((*ranluxclstate).s13to16), &((*ranluxclstate).s05to08), &((*ranluxclstate).carryin24stepnr));
			}
		}
#endif //RANLUXCL_PLANAR

		//Initial skips brought stepnr down to 0. The bulk skips did only full cycles.
		//Therefore stepnr is now equal to remainingskips.
		(*ranluxclstate).carryin24stepnr.z = (float)remainingskips;
	}

	return out;
}

void ranluxcl_synchronize(ranluxcl_state_t *ranluxclstate){
	//This function generates numbers so that the generator is at the beginning,
	//i.e. ready to generate 24 numbers before the next skipping sequence. This is
	//useful if different work-items have called ranluxcl a different number of times.
	//Since that would lead to out of sync execution it could be rather inefficient on
	//SIMD architectures like GPUs. This function thus allows us to resynchronize
	//execution across all work-items.

	//Do necessary number of calls to ranluxcl so that stepnr == 0 at the end.
	if((*ranluxclstate).carryin24stepnr.z == 4.0f)
		ranluxcl(ranluxclstate);
	if((*ranluxclstate).carryin24stepnr.z == 8.0f)
		ranluxcl(ranluxclstate);
	if((*ranluxclstate).carryin24stepnr.z == 12.0f)
		ranluxcl(ranluxclstate);
	if((*ranluxclstate).carryin24stepnr.z == 16.0f)
		ranluxcl(ranluxclstate);
	if((*ranluxclstate).carryin24stepnr.z == 20.0f)
		ranluxcl(ranluxclstate);
}

void ranluxcl_initialization(int ins, global float4 *ranluxcltab)
{
	#define IC 2147483563
	#define ITWO24 16777216

	int scaledins, k, maxWorkitems;

	ranluxcl_state_t rst;

	//Make sure ins isn't negative.
	if(ins < 0)
		ins = 0;

	#ifdef RANLUXCL_MAXWORKITEMS
	maxWorkitems = RANLUXCL_MAXWORKITEMS;
	#else
	maxWorkitems = RANLUXCL_NUMWORKITEMS;
	#endif


	//ins is scaled so that if the user makes another call somewhere else
	//with ins + 1 there should be no overlap. Also adding one
	//allows us to use ins = 0.
	scaledins = ins * maxWorkitems + 1;

	int js = scaledins + RANLUXCL_MYID;

	//Make sure js is not too small (should really be an error)
	if(js < 1)
		js = 1;

	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s01to04.x=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s01to04.y=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s01to04.z=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s01to04.w=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s05to08.x=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s05to08.y=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s05to08.z=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s05to08.w=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s09to12.x=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s09to12.y=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s09to12.z=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s09to12.w=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s13to16.x=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s13to16.y=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s13to16.z=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s13to16.w=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s17to20.x=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s17to20.y=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s17to20.z=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s17to20.w=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s21to24.x=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s21to24.y=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s21to24.z=(js%ITWO24)*RANLUXCL_TWOM24;
	k = js/53668; js=40014*(js-k*53668)-k*12211; if(js<0)js=js+IC; rst.s21to24.w=(js%ITWO24)*RANLUXCL_TWOM24;

	rst.carryin24stepnr.x = 0.0f; //carry
	if(rst.s21to24.w == 0.0f)
		rst.carryin24stepnr.x = RANLUXCL_TWOM24;

	rst.carryin24stepnr.y = 0.0f; //in24
	rst.carryin24stepnr.z = 0.0f; //stepnr

	#ifndef RANLUXCL_NO_WARMUP
	//Warming up the generator, ensuring there are no initial correlations.
	//16 is a "magic number". It is the number of times we must generate
	//a batch of 24 numbers to ensure complete decorrelation.
	for(int i=0; i<16; i++){
		ranluxcl_onestep_1(&(rst.s09to12), &(rst.s21to24), &(rst.carryin24stepnr));
		ranluxcl_onestep_2(&(rst.s09to12), &(rst.s21to24), &(rst.carryin24stepnr));
		ranluxcl_onestep_3(&(rst.s05to08), &(rst.s21to24), &(rst.carryin24stepnr));
		ranluxcl_onestep_4(&(rst.s05to08), &(rst.s21to24), &(rst.carryin24stepnr));
		ranluxcl_onestep_1(&(rst.s05to08), &(rst.s17to20), &(rst.carryin24stepnr));
		ranluxcl_onestep_2(&(rst.s05to08), &(rst.s17to20), &(rst.carryin24stepnr));
		ranluxcl_onestep_3(&(rst.s01to04), &(rst.s17to20), &(rst.carryin24stepnr));
		ranluxcl_onestep_4(&(rst.s01to04), &(rst.s17to20), &(rst.carryin24stepnr));
		ranluxcl_onestep_1(&(rst.s01to04), &(rst.s13to16), &(rst.carryin24stepnr));
		ranluxcl_onestep_2(&(rst.s01to04), &(rst.s13to16), &(rst.carryin24stepnr));
		ranluxcl_onestep_3(&(rst.s21to24), &(rst.s13to16), &(rst.carryin24stepnr));
		ranluxcl_onestep_4(&(rst.s21to24), &(rst.s13to16), &(rst.carryin24stepnr));
		ranluxcl_onestep_1(&(rst.s21to24), &(rst.s09to12), &(rst.carryin24stepnr));
		ranluxcl_onestep_2(&(rst.s21to24), &(rst.s09to12), &(rst.carryin24stepnr));
		ranluxcl_onestep_3(&(rst.s17to20), &(rst.s09to12), &(rst.carryin24stepnr));
		ranluxcl_onestep_4(&(rst.s17to20), &(rst.s09to12), &(rst.carryin24stepnr));
		ranluxcl_onestep_1(&(rst.s17to20), &(rst.s05to08), &(rst.carryin24stepnr));
		ranluxcl_onestep_2(&(rst.s17to20), &(rst.s05to08), &(rst.carryin24stepnr));
		ranluxcl_onestep_3(&(rst.s13to16), &(rst.s05to08), &(rst.carryin24stepnr));
		ranluxcl_onestep_4(&(rst.s13to16), &(rst.s05to08), &(rst.carryin24stepnr));
		ranluxcl_onestep_1(&(rst.s13to16), &(rst.s01to04), &(rst.carryin24stepnr));
		ranluxcl_onestep_2(&(rst.s13to16), &(rst.s01to04), &(rst.carryin24stepnr));
		ranluxcl_onestep_3(&(rst.s09to12), &(rst.s01to04), &(rst.carryin24stepnr));
		ranluxcl_onestep_4(&(rst.s09to12), &(rst.s01to04), &(rst.carryin24stepnr));
	}
	#endif //RANLUXCL_NO_WARMUP

	//Upload the state
	ranluxcl_upload_seed(&rst, ranluxcltab);

	#undef IC
	#undef ITWO24
}

#undef RANLUXCL_TWOM24
#undef RANLUXCL_TWOM12
#undef RANLUXCL_NUMWORKITEMS
#undef RANLUXCL_MYID
#undef RANLUXCL_LUX
#undef RANLUXCL_NSKIP
#undef RANLUXCL_PLANAR
#undef RANLUXCL_NOSKIP
#undef RANLUXCL_NO_WARMUP

#endif //RANLUXCL_CL
